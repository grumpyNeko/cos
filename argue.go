package main

import (
	"fmt"
	"github.com/sashabaranov/go-openai"
)

/*
你说得很有洞察力，从这个角度看，A的论证确实可以被解读为：**他认为一个过于宽泛、将各种情况都囊括进来的“情侣”定义，丧失了其核心的、独特的意义和区分度，因此是“没有现实意义”的。**

让我们重新审视A的逻辑线：

1.  **A的核心观点：** “没有发生性关系就不算男女朋友，因为和普通朋友没有本质区别。”
  - 这明确表达了他认为“性关系”是区分情侣和朋友的**本质**。如果没有这个本质，那么两者就没有区别。

2.  **A对B所提各项要素的回应：**
  - **“共同规划与相互照料”、“共同签署租房合同”、“互为紧急联系人”、“节假日优先安排”：** A认为“这些实际上属于普通朋友范畴”。他的意思是，如果朋友之间都能做这些事，那么这些事就不足以将“情侣”从“朋友”中区分出来。既然朋友也能做，那为什么还要发明一个新词（情侣）来描述这些情况呢？这不就是“没有现实意义”吗？
  - **“排他性的情感承诺”：** A特意强调“你所说的感情不建立在性吸引上”。他暗示，如果这种排他性情感不以性吸引为基础，那它也只是一种深厚的友谊，不足以构成情侣关系。
  - **“见家长、婚约”：** A将其解读为“对未来性关系的承诺”。这表明他认为即使是这些看似强烈的承诺，其最终的意义和目标仍然是指向性关系的。如果没有这个指向，那这些承诺也变得空泛。
  - **“如何称呼彼此/节日优先”：** A直接说“无关紧要”。这同样是为了削弱这些外在表现作为“情侣”定义标准的有效性。

**总结A的立场：**

A认为“情侣”这个词汇之所以有意义，正是因为它包含了一个独特的、其他关系（特别是朋友）所不具备的**核心属性——性关系或性吸引力**。如果去除这个属性，那么所有B所列举的“排他性承诺、情感依附、共同规划、社会认可”等，要么：

*   **朋友也能做到** (例如：深厚友谊的共同规划、相互照料)
*   **不具备情侣关系特有的“浪漫”吸引基础** (A认为浪漫吸引必然包含性吸引)
*   **最终目的仍然指向性** (例如：订婚是对未来性关系的承诺)

因此，在A看来，如果“情侣”可以不包含性，那么它就变得过于模糊，与“朋友”的界限变得难以区分，以至于“情侣”这个词汇本身就失去了其独特的**定义价值和现实区分意义**。他是在争论，如果情侣的定义如此宽泛，那我们根本就不需要“情侣”这个词了，朋友就够了。

从这个角度看，A并不是在简单地循环论证，而是在捍卫一个他认为**更精简、更具有区分力、更符合他认知中“情侣”本质**的定义。他认为B的定义是“发明一个词汇来包含各种情况”，但这种包含却使得这个词汇失去了其应有的“意义”。
*/
const SysPromptArgue = `请用至多3句话尝试反驳用户的观点
要言之有物(只需举一反例), 不要关心道德问题, 不要争夺定义权和命名权
直接返回如下格式的JSON(不含markdown语法):
{
 "user_eng": "..",
 "answer_chs": ".."
 "answer_eng": ".."
}
user_eng是用户输入的英文
answer最多3句话, 非常精炼, 以至于无视语法, 分别给出中英文

历史对话:
%s
`

var sum = `
A: 没性 = 朋友
B: 异地/无性恋呢? 有承诺
A: 朋友也有承诺
B: 一起租房/订婚/见家长呢?
A: 没性, 订婚也算朋友
B: 所以分歧只是“排他”?
A: 对
B: 不止. 还有社会身份. 比如医院探视权, 移民签证, 朋友没有
A: 唯心
B: 制度是客观的
`

var history = []string{
	`A: 没有发生性关系就不算男女朋友, 因为和普通朋友没有本质区别`,
	`B: 将性关系作为唯一标准并不成立：例如有些异地情侣长期未发生性关系，但仍有排他性的情感承诺、共同规划与相互照料，这些已明显区别于普通朋友。恋爱关系可由明确的双向承诺、情感依附和专属互动界定，而非是否发生性行为。若按你的标准，所有纯精神恋爱或先恋爱后婚后性行为的伴侣都无法被认定为恋人，这与现实中大量案例相矛盾。`,
	`A:
所谓"共同规划与相互照料", 与普通朋友没区别
所谓"排他性的情感承诺", 注意你所说的感情不建立在性吸引上`,
	`B: 
把性作为必要条件会导致反例：许多无性恋或暂时禁欲的伴侣在明确排他关系、共同财务和生活决策上与普通朋友截然不同（例如共同签署租房合同、互为紧急联系人、节假日优先安排与边界约定）。此外，恋爱可以由浪漫吸引或承诺机制区分于友情，现实中存在强烈浪漫依恋但低性欲的情侣，与普通朋友的非排他与低承诺结构并不相同。若性是唯一判据，则这些稳定伴侣在发生性行为前都被视为“非情侣”，与他们在法律与社会实践中的对待（如伴侣优先权、共同决策）相矛盾。`,
	`A: 你所说正好支持了我的说法, 共同签署租房合同、互为紧急联系人、节假日优先安排, 这些实际上属于普通朋友范畴`,
	`B: 将这些举动视为“普通朋友范畴”与现实反例不符：例如无性恋伴侣或宗教背景下婚前禁欲的情侣，会有公开的排他认定、伴侣优先的决策权与界限（如避免与他人暧昧、共同财务预算、见家长与订婚），这些在普通朋友关系中通常不存在。若性是必要条件，那么一对已订婚但尚未发生性行为的情侣将被归为“普通朋友”，这与他们的排他性、社会认可与法律筹备（婚约、婚礼安排）事实相矛盾。`,
	`A: 所以已订婚但尚未发生性行为的情侣是“普通朋友”啊`,
	`B: 这一结论与反例不符：许多已订婚但婚前禁欲的伴侣在法律与社会实践上享有并履行排他与承诺（见家长、婚约、共同筹备婚礼与财务绑定），这些结构化排他与角色期望并非普通朋友会有。若仍称其为“普通朋友”，则需解释为何社会与法律会对“普通朋友”赋予订婚、继承与家庭决策等预期与权益，这与现实运作相冲突。`,
	`A: "见家长、婚约"是对未来性关系的承诺, 而财务绑定我不同意`,
	`B: 把订婚等同普通朋友会遇到反例：许多无性恋伴侣终身无性但已订婚或结婚，仍具明确的排他角色、法律与社会认可，与普通朋友不同。即便剔除财务绑定，订婚的法律效力与社会身份（婚约解除责任、亲属称谓、伴侣优先权）在未发生性行为前已生效，这些并非“对未来性关系”的简单承诺。若坚持以性为必要条件，则这些无性婚姻与长期浪漫伴侣都被归为“普通朋友”，与其公开身份与制度安排相矛盾。`,
	`A: 所以我们唯一的分歧在于"排他性"?`,
	`B: 分歧不只在“排他性”的存在，而在排他性的类型：恋爱中的排他通常包含浪漫/亲密边界与角色期望（如对暧昧互动的限制、共同身份对外宣示），而普通朋友缺乏这种结构化排他。反例：无性恋情侣虽无性行为，但对第三者暧昧设限、公开以伴侣自称、共同做生活重大决策，已与普通朋友的非排他、低角色约束显著不同。若将性作为唯一标准，连这些明确定义关系和边界的伴侣也要归入“普通朋友”，与其对外身份与实际运行相冲突。`,
	`A: 哪里不一样? 请举例`,
	`B: 无性恋已婚伴侣可共同报税、自动继承、被默认为医疗决策第一人，这些是法律赋予的伴侣专属排他性，普通朋友即便再亲密也不能。再者，移居选择、职业牺牲等长期资源分配常设为“一对一”协商框架，朋友关系通常是多边且非排他的。若仅用“没性=朋友”，无法解释这些制度化与资源排他带来的差异`,
	`A: 我问的是男女朋友/情侣, 不是已婚关系`,
	`B: 同居情侣常共享长期租约、联名大件支出与专属时间安排（如节假日优先权），朋友即便亲密也少有此排他配置。再者，医疗告知、社交公开身份（带对方参加仅限伴侣的活动）与异地两地择一的迁居决策，情侣默认一对一排他协商，朋友通常非此框架。仅以“没性=朋友”无法解释这些排他投入与角色优先级。`,
	`A: 所以不同居的无性关系的未婚=朋友`,
	`B: 即便不同居，情侣常有明示的排他协议（例如双方停止与他人约会），朋友关系通常不做此承诺。另一个反例：许多活动与福利将“伴侣/恋人”作为唯一有效的邀请或名册身份，朋友不被等同承认。若仅因无性与不同居就等同朋友，无法解释这种制度与承诺层面的差异`,
	`A: 所以分歧是“排他性”？`,
	`B: 不止排他性。反例：有的人与朋友也互不再约会他人，但仍不会被视为情侣；情侣还包含角色期待与未来规划（如见家长、共同预算节点），这些朋友的排他无法复制。仅用“排他性”不足以区分两者。`,
	`A: 如果也没有共同预算呢`,
	`B: 即便无同居、无性、无共同预算，双方互称彼此为男女朋友、停止与他人约会、见家长并在社交中以伴侣身份出现，这些身份与承诺区隔于朋友。另一个反例：许多情侣会设定节日优先权与关系边界（例如冲突处理、定期关系检视），朋友很少采用这种一对一框架。由此可见，身份与承诺结构仍使其不同于朋友`,
	`A: 所以分歧是“排他性”？`,
	`B: 不止排他性。反例：有朋友彼此承诺不再约会他人仍不被视为情侣；而情侣会公开互称伴侣、设定节日优先权、见家长，这些身份与角色预期并非单靠排他能解释。`,
	`A: 如何称呼彼此/节日优先是无关紧要的`,
	`B: 有情侣不在意称呼与节假日，但会共同做长期决策如异地择一、排他性冲突处理协议与未来里程碑（见家长/搬迁时机）；朋友即便亲密也少在一对一框架内制定这些决策。若这些也都没有，仍自我与他人处以“伴侣”身份并承担相应期望，本身就与朋友不同`,
	`A: 这是唯心的`,
	`B: 反例：移民配偶签、公司伴侣福利、医院探视与病情告知权限等制度性差异并非“唯心”，同样的两人若被认定为伴侣可享受，称作朋友则不行。仅以“唯心”无法解释这些客观制度后果`,
}

func Argue(s []openai.ChatCompletionMessage) []openai.ChatCompletionMessage {
	if s[0].Role != openai.ChatMessageRoleSystem {
		panic(`s[0].Role != openai.ChatMessageRoleSystem`)
	}
	s[0].Content = fmt.Sprintf(SysPromptArgue, sum)
	return s
}
